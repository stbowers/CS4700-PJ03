KW_CLASS, class
IDENT, Ball
SY_LBRACE, {
KW_VARDEC, field
KW_TYPE, int
IDENT, x
SY_COMMA, ,
IDENT, y
SY_SEMI, ;
KW_VARDEC, field
KW_TYPE, int
IDENT, lengthx
SY_COMMA, ,
IDENT, lengthy
SY_SEMI, ;
KW_VARDEC, field
KW_TYPE, int
IDENT, d
SY_COMMA, ,
IDENT, straightD
SY_COMMA, ,
IDENT, diagonalD
SY_SEMI, ;
KW_VARDEC, field
KW_TYPE, boolean
IDENT, invert
SY_COMMA, ,
IDENT, positivex
SY_COMMA, ,
IDENT, positivey
SY_SEMI, ;
KW_VARDEC, field
KW_TYPE, int
IDENT, leftWall
SY_COMMA, ,
IDENT, rightWall
SY_COMMA, ,
IDENT, topWall
SY_COMMA, ,
IDENT, bottomWall
SY_SEMI, ;
KW_VARDEC, field
KW_TYPE, int
IDENT, wall
SY_SEMI, ;
KW_SUBDEC, constructor
IDENT, Ball
IDENT, new
SY_LPAREN, (
KW_TYPE, int
IDENT, Ax
SY_COMMA, ,
KW_TYPE, int
IDENT, Ay
SY_COMMA, ,
KW_TYPE, int
IDENT, AleftWall
SY_COMMA, ,
KW_TYPE, int
IDENT, ArightWall
SY_COMMA, ,
KW_TYPE, int
IDENT, AtopWall
SY_COMMA, ,
KW_TYPE, int
IDENT, AbottomWall
SY_RPAREN, )
SY_LBRACE, {
KW_LET, let
IDENT, x
SY_EQ, =
IDENT, Ax
SY_SEMI, ;
KW_LET, let
IDENT, y
SY_EQ, =
IDENT, Ay
SY_SEMI, ;
KW_LET, let
IDENT, leftWall
SY_EQ, =
IDENT, AleftWall
SY_SEMI, ;
KW_LET, let
IDENT, rightWall
SY_EQ, =
IDENT, ArightWall
SY_MINUS, -
INTEGER, 6
SY_SEMI, ;
KW_LET, let
IDENT, topWall
SY_EQ, =
IDENT, AtopWall
SY_SEMI, ;
KW_LET, let
IDENT, bottomWall
SY_EQ, =
IDENT, AbottomWall
SY_MINUS, -
INTEGER, 6
SY_SEMI, ;
KW_LET, let
IDENT, wall
SY_EQ, =
INTEGER, 0
SY_SEMI, ;
KW_DO, do
IDENT, show
SY_LPAREN, (
SY_RPAREN, )
SY_SEMI, ;
KW_RETURN, return
KW_CONST, this
SY_SEMI, ;
SY_RBRACE, }
KW_SUBDEC, method
KW_VOID, void
IDENT, dispose
SY_LPAREN, (
SY_RPAREN, )
SY_LBRACE, {
KW_DO, do
IDENT, Memory
SY_PERIOD, .
IDENT, deAlloc
SY_LPAREN, (
KW_CONST, this
SY_RPAREN, )
SY_SEMI, ;
KW_RETURN, return
SY_SEMI, ;
SY_RBRACE, }
KW_SUBDEC, method
KW_VOID, void
IDENT, show
SY_LPAREN, (
SY_RPAREN, )
SY_LBRACE, {
KW_DO, do
IDENT, Screen
SY_PERIOD, .
IDENT, setColor
SY_LPAREN, (
KW_CONST, true
SY_RPAREN, )
SY_SEMI, ;
KW_DO, do
IDENT, draw
SY_LPAREN, (
SY_RPAREN, )
SY_SEMI, ;
KW_RETURN, return
SY_SEMI, ;
SY_RBRACE, }
KW_SUBDEC, method
KW_VOID, void
IDENT, hide
SY_LPAREN, (
SY_RPAREN, )
SY_LBRACE, {
KW_DO, do
IDENT, Screen
SY_PERIOD, .
IDENT, setColor
SY_LPAREN, (
KW_CONST, false
SY_RPAREN, )
SY_SEMI, ;
KW_DO, do
IDENT, draw
SY_LPAREN, (
SY_RPAREN, )
SY_SEMI, ;
KW_RETURN, return
SY_SEMI, ;
SY_RBRACE, }
KW_SUBDEC, method
KW_VOID, void
IDENT, draw
SY_LPAREN, (
SY_RPAREN, )
SY_LBRACE, {
KW_DO, do
IDENT, Screen
SY_PERIOD, .
IDENT, drawRectangle
SY_LPAREN, (
IDENT, x
SY_COMMA, ,
IDENT, y
SY_COMMA, ,
IDENT, x
SY_OP, +
INTEGER, 5
SY_COMMA, ,
IDENT, y
SY_OP, +
INTEGER, 5
SY_RPAREN, )
SY_SEMI, ;
KW_RETURN, return
SY_SEMI, ;
SY_RBRACE, }
KW_SUBDEC, method
KW_TYPE, int
IDENT, getLeft
SY_LPAREN, (
SY_RPAREN, )
SY_LBRACE, {
KW_RETURN, return
IDENT, x
SY_SEMI, ;
SY_RBRACE, }
KW_SUBDEC, method
KW_TYPE, int
IDENT, getRight
SY_LPAREN, (
SY_RPAREN, )
SY_LBRACE, {
KW_RETURN, return
IDENT, x
SY_OP, +
INTEGER, 5
SY_SEMI, ;
SY_RBRACE, }
KW_SUBDEC, method
KW_VOID, void
IDENT, setDestination
SY_LPAREN, (
KW_TYPE, int
IDENT, destx
SY_COMMA, ,
KW_TYPE, int
IDENT, desty
SY_RPAREN, )
SY_LBRACE, {
KW_VAR, var
KW_TYPE, int
IDENT, dx
SY_COMMA, ,
IDENT, dy
SY_COMMA, ,
IDENT, temp
SY_SEMI, ;
KW_LET, let
IDENT, lengthx
SY_EQ, =
IDENT, destx
SY_MINUS, -
IDENT, x
SY_SEMI, ;
KW_LET, let
IDENT, lengthy
SY_EQ, =
IDENT, desty
SY_MINUS, -
IDENT, y
SY_SEMI, ;
KW_LET, let
IDENT, dx
SY_EQ, =
IDENT, Math
SY_PERIOD, .
IDENT, abs
SY_LPAREN, (
IDENT, lengthx
SY_RPAREN, )
SY_SEMI, ;
KW_LET, let
IDENT, dy
SY_EQ, =
IDENT, Math
SY_PERIOD, .
IDENT, abs
SY_LPAREN, (
IDENT, lengthy
SY_RPAREN, )
SY_SEMI, ;
KW_LET, let
IDENT, invert
SY_EQ, =
SY_LPAREN, (
IDENT, dx
SY_OP, <
IDENT, dy
SY_RPAREN, )
SY_SEMI, ;
KW_IF, if
SY_LPAREN, (
IDENT, invert
SY_RPAREN, )
SY_LBRACE, {
KW_LET, let
IDENT, temp
SY_EQ, =
IDENT, dx
SY_SEMI, ;
KW_LET, let
IDENT, dx
SY_EQ, =
IDENT, dy
SY_SEMI, ;
KW_LET, let
IDENT, dy
SY_EQ, =
IDENT, temp
SY_SEMI, ;
KW_LET, let
IDENT, positivex
SY_EQ, =
SY_LPAREN, (
IDENT, y
SY_OP, <
IDENT, desty
SY_RPAREN, )
SY_SEMI, ;
KW_LET, let
IDENT, positivey
SY_EQ, =
SY_LPAREN, (
IDENT, x
SY_OP, <
IDENT, destx
SY_RPAREN, )
SY_SEMI, ;
SY_RBRACE, }
KW_ELSE, else
SY_LBRACE, {
KW_LET, let
IDENT, positivex
SY_EQ, =
SY_LPAREN, (
IDENT, x
SY_OP, <
IDENT, destx
SY_RPAREN, )
SY_SEMI, ;
KW_LET, let
IDENT, positivey
SY_EQ, =
SY_LPAREN, (
IDENT, y
SY_OP, <
IDENT, desty
SY_RPAREN, )
SY_SEMI, ;
SY_RBRACE, }
KW_LET, let
IDENT, d
SY_EQ, =
SY_LPAREN, (
INTEGER, 2
SY_OP, *
IDENT, dy
SY_RPAREN, )
SY_MINUS, -
IDENT, dx
SY_SEMI, ;
KW_LET, let
IDENT, straightD
SY_EQ, =
INTEGER, 2
SY_OP, *
IDENT, dy
SY_SEMI, ;
KW_LET, let
IDENT, diagonalD
SY_EQ, =
INTEGER, 2
SY_OP, *
SY_LPAREN, (
IDENT, dy
SY_MINUS, -
IDENT, dx
SY_RPAREN, )
SY_SEMI, ;
KW_RETURN, return
SY_SEMI, ;
SY_RBRACE, }
KW_SUBDEC, method
KW_TYPE, int
IDENT, move
SY_LPAREN, (
SY_RPAREN, )
SY_LBRACE, {
KW_DO, do
IDENT, hide
SY_LPAREN, (
SY_RPAREN, )
SY_SEMI, ;
KW_IF, if
SY_LPAREN, (
IDENT, d
SY_OP, <
INTEGER, 0
SY_RPAREN, )
SY_LBRACE, {
KW_LET, let
IDENT, d
SY_EQ, =
IDENT, d
SY_OP, +
IDENT, straightD
SY_SEMI, ;
SY_RBRACE, }
KW_ELSE, else
SY_LBRACE, {
KW_LET, let
IDENT, d
SY_EQ, =
IDENT, d
SY_OP, +
IDENT, diagonalD
SY_SEMI, ;
KW_IF, if
SY_LPAREN, (
IDENT, positivey
SY_RPAREN, )
SY_LBRACE, {
KW_IF, if
SY_LPAREN, (
IDENT, invert
SY_RPAREN, )
SY_LBRACE, {
KW_LET, let
IDENT, x
SY_EQ, =
IDENT, x
SY_OP, +
INTEGER, 4
SY_SEMI, ;
SY_RBRACE, }
KW_ELSE, else
SY_LBRACE, {
KW_LET, let
IDENT, y
SY_EQ, =
IDENT, y
SY_OP, +
INTEGER, 4
SY_SEMI, ;
SY_RBRACE, }
SY_RBRACE, }
KW_ELSE, else
SY_LBRACE, {
KW_IF, if
SY_LPAREN, (
IDENT, invert
SY_RPAREN, )
SY_LBRACE, {
KW_LET, let
IDENT, x
SY_EQ, =
IDENT, x
SY_MINUS, -
INTEGER, 4
SY_SEMI, ;
SY_RBRACE, }
KW_ELSE, else
SY_LBRACE, {
KW_LET, let
IDENT, y
SY_EQ, =
IDENT, y
SY_MINUS, -
INTEGER, 4
SY_SEMI, ;
SY_RBRACE, }
SY_RBRACE, }
SY_RBRACE, }
KW_IF, if
SY_LPAREN, (
IDENT, positivex
SY_RPAREN, )
SY_LBRACE, {
KW_IF, if
SY_LPAREN, (
IDENT, invert
SY_RPAREN, )
SY_LBRACE, {
KW_LET, let
IDENT, y
SY_EQ, =
IDENT, y
SY_OP, +
INTEGER, 4
SY_SEMI, ;
SY_RBRACE, }
KW_ELSE, else
SY_LBRACE, {
KW_LET, let
IDENT, x
SY_EQ, =
IDENT, x
SY_OP, +
INTEGER, 4
SY_SEMI, ;
SY_RBRACE, }
SY_RBRACE, }
KW_ELSE, else
SY_LBRACE, {
KW_IF, if
SY_LPAREN, (
IDENT, invert
SY_RPAREN, )
SY_LBRACE, {
KW_LET, let
IDENT, y
SY_EQ, =
IDENT, y
SY_MINUS, -
INTEGER, 4
SY_SEMI, ;
SY_RBRACE, }
KW_ELSE, else
SY_LBRACE, {
KW_LET, let
IDENT, x
SY_EQ, =
IDENT, x
SY_MINUS, -
INTEGER, 4
SY_SEMI, ;
SY_RBRACE, }
SY_RBRACE, }
KW_IF, if
SY_LPAREN, (
SY_NOT, ~
SY_LPAREN, (
IDENT, x
SY_OP, >
IDENT, leftWall
SY_RPAREN, )
SY_RPAREN, )
SY_LBRACE, {
KW_LET, let
IDENT, wall
SY_EQ, =
INTEGER, 1
SY_SEMI, ;
KW_LET, let
IDENT, x
SY_EQ, =
IDENT, leftWall
SY_SEMI, ;
SY_RBRACE, }
KW_IF, if
SY_LPAREN, (
SY_NOT, ~
SY_LPAREN, (
IDENT, x
SY_OP, <
IDENT, rightWall
SY_RPAREN, )
SY_RPAREN, )
SY_LBRACE, {
KW_LET, let
IDENT, wall
SY_EQ, =
INTEGER, 2
SY_SEMI, ;
KW_LET, let
IDENT, x
SY_EQ, =
IDENT, rightWall
SY_SEMI, ;
SY_RBRACE, }
KW_IF, if
SY_LPAREN, (
SY_NOT, ~
SY_LPAREN, (
IDENT, y
SY_OP, >
IDENT, topWall
SY_RPAREN, )
SY_RPAREN, )
SY_LBRACE, {
KW_LET, let
IDENT, wall
SY_EQ, =
INTEGER, 3
SY_SEMI, ;
KW_LET, let
IDENT, y
SY_EQ, =
IDENT, topWall
SY_SEMI, ;
SY_RBRACE, }
KW_IF, if
SY_LPAREN, (
SY_NOT, ~
SY_LPAREN, (
IDENT, y
SY_OP, <
IDENT, bottomWall
SY_RPAREN, )
SY_RPAREN, )
SY_LBRACE, {
KW_LET, let
IDENT, wall
SY_EQ, =
INTEGER, 4
SY_SEMI, ;
KW_LET, let
IDENT, y
SY_EQ, =
IDENT, bottomWall
SY_SEMI, ;
SY_RBRACE, }
KW_DO, do
IDENT, show
SY_LPAREN, (
SY_RPAREN, )
SY_SEMI, ;
KW_RETURN, return
IDENT, wall
SY_SEMI, ;
SY_RBRACE, }
KW_SUBDEC, method
KW_VOID, void
IDENT, bounce
SY_LPAREN, (
KW_TYPE, int
IDENT, bouncingDirection
SY_RPAREN, )
SY_LBRACE, {
KW_VAR, var
KW_TYPE, int
IDENT, newx
SY_COMMA, ,
IDENT, newy
SY_COMMA, ,
IDENT, divLengthx
SY_COMMA, ,
IDENT, divLengthy
SY_COMMA, ,
IDENT, factor
SY_SEMI, ;
KW_LET, let
IDENT, divLengthx
SY_EQ, =
IDENT, lengthx
SY_OP, /
INTEGER, 10
SY_SEMI, ;
KW_LET, let
IDENT, divLengthy
SY_EQ, =
IDENT, lengthy
SY_OP, /
INTEGER, 10
SY_SEMI, ;
KW_IF, if
SY_LPAREN, (
IDENT, bouncingDirection
SY_EQ, =
INTEGER, 0
SY_RPAREN, )
SY_LBRACE, {
KW_LET, let
IDENT, factor
SY_EQ, =
INTEGER, 10
SY_SEMI, ;
SY_RBRACE, }
KW_ELSE, else
SY_LBRACE, {
KW_IF, if
SY_LPAREN, (
SY_LPAREN, (
SY_NOT, ~
SY_LPAREN, (
IDENT, lengthx
SY_OP, <
INTEGER, 0
SY_RPAREN, )
SY_RPAREN, )
SY_OP, &
SY_LPAREN, (
IDENT, bouncingDirection
SY_EQ, =
INTEGER, 1
SY_RPAREN, )
SY_OP, |
SY_LPAREN, (
IDENT, lengthx
SY_OP, <
INTEGER, 0
SY_RPAREN, )
SY_OP, &
SY_LPAREN, (
IDENT, bouncingDirection
SY_EQ, =
SY_LPAREN, (
SY_MINUS, -
INTEGER, 1
SY_RPAREN, )
SY_RPAREN, )
SY_RPAREN, )
SY_LBRACE, {
KW_LET, let
IDENT, factor
SY_EQ, =
INTEGER, 20
SY_SEMI, ;
SY_RBRACE, }
KW_ELSE, else
SY_LBRACE, {
KW_LET, let
IDENT, factor
SY_EQ, =
INTEGER, 5
SY_SEMI, ;
SY_RBRACE, }
SY_RBRACE, }
KW_IF, if
SY_LPAREN, (
IDENT, wall
SY_EQ, =
INTEGER, 1
SY_RPAREN, )
SY_LBRACE, {
KW_LET, let
IDENT, newx
SY_EQ, =
INTEGER, 506
SY_SEMI, ;
KW_LET, let
IDENT, newy
SY_EQ, =
SY_LPAREN, (
IDENT, divLengthy
SY_OP, *
SY_LPAREN, (
SY_MINUS, -
INTEGER, 50
SY_RPAREN, )
SY_RPAREN, )
SY_OP, /
IDENT, divLengthx
SY_SEMI, ;
KW_LET, let
IDENT, newy
SY_EQ, =
IDENT, y
SY_OP, +
SY_LPAREN, (
IDENT, newy
SY_OP, *
IDENT, factor
SY_RPAREN, )
SY_SEMI, ;
SY_RBRACE, }
KW_ELSE, else
SY_LBRACE, {
KW_IF, if
SY_LPAREN, (
IDENT, wall
SY_EQ, =
INTEGER, 2
SY_RPAREN, )
SY_LBRACE, {
KW_LET, let
IDENT, newx
SY_EQ, =
INTEGER, 0
SY_SEMI, ;
KW_LET, let
IDENT, newy
SY_EQ, =
SY_LPAREN, (
IDENT, divLengthy
SY_OP, *
INTEGER, 50
SY_RPAREN, )
SY_OP, /
IDENT, divLengthx
SY_SEMI, ;
KW_LET, let
IDENT, newy
SY_EQ, =
IDENT, y
SY_OP, +
SY_LPAREN, (
IDENT, newy
SY_OP, *
IDENT, factor
SY_RPAREN, )
SY_SEMI, ;
SY_RBRACE, }
KW_ELSE, else
SY_LBRACE, {
KW_IF, if
SY_LPAREN, (
IDENT, wall
SY_EQ, =
INTEGER, 3
SY_RPAREN, )
SY_LBRACE, {
KW_LET, let
IDENT, newy
SY_EQ, =
INTEGER, 250
SY_SEMI, ;
KW_LET, let
IDENT, newx
SY_EQ, =
SY_LPAREN, (
IDENT, divLengthx
SY_OP, *
SY_LPAREN, (
SY_MINUS, -
INTEGER, 25
SY_RPAREN, )
SY_RPAREN, )
SY_OP, /
IDENT, divLengthy
SY_SEMI, ;
KW_LET, let
IDENT, newx
SY_EQ, =
IDENT, x
SY_OP, +
SY_LPAREN, (
IDENT, newx
SY_OP, *
IDENT, factor
SY_RPAREN, )
SY_SEMI, ;
SY_RBRACE, }
KW_ELSE, else
SY_LBRACE, {
KW_LET, let
IDENT, newy
SY_EQ, =
INTEGER, 0
SY_SEMI, ;
KW_LET, let
IDENT, newx
SY_EQ, =
SY_LPAREN, (
IDENT, divLengthx
SY_OP, *
INTEGER, 25
SY_RPAREN, )
SY_OP, /
IDENT, divLengthy
SY_SEMI, ;
KW_LET, let
IDENT, newx
SY_EQ, =
IDENT, x
SY_OP, +
SY_LPAREN, (
IDENT, newx
SY_OP, *
IDENT, factor
SY_RPAREN, )
SY_SEMI, ;
SY_RBRACE, }
SY_RBRACE, }
SY_RBRACE, }
KW_DO, do
IDENT, setDestination
SY_LPAREN, (
IDENT, newx
SY_COMMA, ,
IDENT, newy
SY_RPAREN, )
SY_SEMI, ;
KW_RETURN, return
SY_SEMI, ;
SY_RBRACE, }
SY_RBRACE, }
